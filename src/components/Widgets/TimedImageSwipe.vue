<template>
  <div class="imageSwipe" v-if="showStimuli">
    <transition :key="swipe" :name="swipe">
      <div class="user-card" :key="baseUrl">
        <div class="image_area">
          <progressive-img
            :class="[
              'user-card__picture',
              'mx-auto',
              widgetProperties.timing.stimulusFadeIn ? '' : 'no-fade-in'
            ]"
            :src="baseUrl"
            v-hammer:swipe.horizontal="onSwipe"
            placeholder="https://unsplash.it/500"
            :aspect-ratio="1"
            @onLoad="onImgLoad"
          >
          </progressive-img>
        </div>

        <div class="user-card__name">
          <b-button
            variant="danger"
            v-if="playMode"
            style="float:left"
            @click="swipeLeft"
            v-shortkey="['arrowleft']"
            @shortkey="swipeLeft"
            v-hammer:swipe.left="swipeLeft"
            ref="leftSwipe"
          >
            <i class="fa fa-long-arrow-left" aria-hidden="true"></i>
            {{ widgetProperties.leftSwipe.label }}
          </b-button>

          <span style="float:left" v-else>
            <span v-if="widgetSummary">
              ave vote: {{ widgetSummary.aveVote || 0 }}
            </span>
            <span v-else>ave vote: N/A</span>
          </span>

          <b-button
            v-if="playMode"
            :to="'/review/' + widgetPointer"
            ref="helpButton"
            class="helpbtn"
            >Help</b-button
          >

          <b-button
            variant="success"
            v-if="playMode"
            style="float:right"
            @click="swipeRight"
            v-shortkey="['arrowright']"
            @shortkey="swipeRight"
            ref="rightSwipe"
          >
            {{ widgetProperties.rightSwipe.label }}
            <i class="fa fa-long-arrow-right" aria-hidden="true"></i>
          </b-button>

          <span style="float:right" v-else>
            <span v-if="widgetSummary">
              num votes: {{ widgetSummary.count || 0 }}
            </span>
            <span v-else>num votes: 0</span>
          </span>
        </div>
      </div>
    </transition>
  </div>
</template>

<script>
/**
 * The TimedImageSwipe widget is build on the original, https://braindr.us Tinder-like widget
 * where you swipe left to "fail" an image, and swipe right to  "pass" it.
 * It is for binary classification only.
 * It differs from the original in that it the stimulus duration is configurable.
 */
import _ from "lodash";
import Vue from "vue";
import { VueHammer } from "vue2-hammer";
import imagesLoaded from "vue-images-loaded";
import GridLoader from "vue-spinner/src/PulseLoader";
import VueProgressiveImage from "../../../node_modules/vue-progressive-image/dist/vue-progressive-image";

Vue.use(VueProgressiveImage);
Vue.use(VueHammer);
Vue.use(require("vue-shortkey"));

export default {
  name: "TimedImageSwipe",
  props: {
    /**
     * The sample ID to tell the widget to display.
     */
    widgetPointer: {
      type: String,
      required: true
    },
    /**
     * The widget-specific properties. The schema is widget specific.
     */
    widgetProperties: {
      type: Object,
      required: true
    },
    /**
     * The summary data for the widget.
     * This one keeps track of the running average.
     */
    widgetSummary: {
      type: Object,
      required: false
    },
    /**
     * The user's settings on the widget. The schema is widget specific.
     */
    userSettings: {
      type: Object,
      required: true
    },
    /**
     * Tells the widget if it should be in a "play mode" or maybe a "review mode".
     */
    playMode: {
      type: String,
      required: false
    },
    /**
     * Tells the widget to display a tutorial step.
     * tutorialStep = 0 highlights/glows the pass button.
     * tutorialStep = 1 highlights/glows the fail button.
     * tutorialStep = 2 highlights/glows the help button.
     */
    tutorialStep: {
      type: Number,
      required: false
    }
  },
  // eslint-disable-next-line
  components: { VueHammer, GridLoader },
  directives: {
    imagesLoaded
  },
  data() {
    return {
      /**
       * the status of the image to load
       */
      status: "loading",
      /**
       * save the swipe direction.
       */
      swipe: null,
      /**
       * Timer object for frame duration handling.
       * Used when `widgetProperties.timing.stimulusDuration` is set.
       */
      durationTimer: null,
      /**
       * Timer object for inter-stimuli duration handling.
       * Used when `widgetProperties.timing.interStimuliDuration` is set.
       */
      interStimuliTimer: null,
      /**
       * flag to hide stimulus if `widgetProperties.timing.interStimuliDuration` is set.
       */
      showStimuli: true
    };
  },
  computed: {
    /**
     * Compute the baseURL based on baseUrlTemplate and delimiter of the widgetProperties,
     * and the widgetPointer. For example a widgetPointer="contrast1__image1" could be
     * mapped to https://base_url/contrast1/image1.jpg if
     * baseUrlTemplate = 'https://base_url/{0}/{1}.jpg' and delimiter === '__'.
     */
    baseUrl() {
      return this.widgetProperties.baseUrlTemplate && this.widgetPointer
        ? this.fillPropertyPattern(
            this.widgetProperties.baseUrlTemplate,
            this.widgetProperties.delimiter
          )
        : null;
    },
    timing() {
      return this.playMode === "tutorial" ? {} : this.widgetProperties.timing;
    }
  },
  watch: {
    /**
     * Watch the widget pointer, which is from `/sampleCounts` document in firebase.
     * When it changes, also update the `widgetSummary` to be from the new `widgetPointer`.
     */
    widgetPointer() {
      this.preImgLoad();
    }
  },
  /**
   * If the playMode === 'tutorial', show a tutorial step.
   */
  mounted() {
    this.$nextTick(() => {
      if (this.playMode === "tutorial") {
        this.showTutorialStep(this.tutorialStep);
      }
    });
  },
  beforeUnmount() {
    clearTimeout(this.durationTimer);
    clearTimeout(this.interStimuliTimer);
  },
  methods: {
    /**
     * Show a tutorial step
     */
    showTutorialStep(stepNumber) {
      switch (stepNumber) {
        case 0:
          // highlight the pass button
          this.$refs.rightSwipe.classList.add("focus");
          break;
        case 1:
          // highlight the fail button
          this.$refs.leftSwipe.classList.add("focus");
          break;
        case 2:
          // highlight the help button
          this.$refs.helpButton.classList.add("focus");
          break;
        default:
          break;
      }
    },
    preImgLoad() {
      const interStimuliDuration = this.timing.interStimuliDuration;
      if (interStimuliDuration) {
        this.showStimuli = false;
        this.interStimuliTimer = setTimeout(() => {
          this.showStimuli = true;
          clearTimeout(this.interStimuliTimer);
        }, interStimuliDuration);
      }
    },
    /**
     * Set a duration timer on image load if stimulusDuration is configured.
     */
    onImgLoad() {
      this.$emit("setStartTime", new Date());
      if (this.timing.stimulusDuration) {
        this.durationTimer = setTimeout(() => {
          this.vote(this.timing.timeoutValue);
        }, this.timing.stimulusDuration);
      }
    },
    /**
     * Fill a pattern by `this.widgetPointer` based on a delimiter.
     */
    fillPropertyPattern(pattern, delimiter) {
      // fill the pattern by splitting the widgetPointer by delimiter
      let output = pattern;
      const parts = String(this.widgetPointer).split(delimiter);
      _.map(parts, (p, i) => {
        output = output.replace(`{${i}}`, p);
      });
      return output;
    },
    /**
     * Get the score based on a user's response.
     */
    getScore(response) {
      const fb = this.getFeedback(response);
      if (fb.variant === "danger") {
        return 0;
      }
      return 1;
    },
    /**
     * Get the feedback based on a user's response.
     */
    getFeedback(response) {
      let widgetSummary;
      if (!this.widgetSummary) {
        widgetSummary = {
          count: 0
        };
      } else {
        widgetSummary = this.widgetSummary;
      }
      if (widgetSummary.count > 4) {
        // if this sample has been seen more than 4 times
        // count the number of points
        const aveVote = widgetSummary.aveVote;

        if (aveVote >= 0.7 && !response) {
          // on average, most people gave this sample some points. If you didn't, lose a point
          return {
            show: false,
            variant: "danger",
            message: "+0 most people swiped right"
          };
        } else if (aveVote <= 0.3 && response) {
          // on average, most people did not mark this image, but you did
          return {
            show: false,
            variant: "danger",
            message: "+0 most people swiped left"
          };
        }

        return {
          show: true,
          variant: "success",
          message: "+1 good job"
        };
      }

      return {
        show: true,
        variant: "success",
        message: "+1 thanks"
      };
    },
    /**
     * get the widget's new summary based on a user's response.
     * in this case its a running average.
     */
    getSummary(response) {
      // this widget will keep track of
      // the number of votes and the average vote
      if (!this.widgetSummary) {
        // the summary isn't initialized yet
        return {
          aveVote: response,
          count: 1
        };
      }

      let newVote =
        this.widgetSummary.aveVote * this.widgetSummary.count + response;
      newVote /= this.widgetSummary.count + 1;

      return {
        aveVote: newVote,
        count: this.widgetSummary.count + 1
      };
    },
    /**
     * emit an annotation to the parent.
     */
    vote(val) {
      if (this.playMode === "tutorial") {
        this.tutorialVote(val);
      } else {
        this.$emit("widgetRating", val);
        clearTimeout(this.durationTimer);
        clearTimeout(this.interStimuliTimer);
      }
    },
    /**
     * emit a correct/incorrect answer to parent
     */
    tutorialVote(value) {
      this.$emit("widgetRating", {
        pointer: this.widgetPointer,
        value
      });
    },
    /**
     * This method should tell users how their widgetProperties configuration should be defined.
     */
    getPropertiesSchema() {
      return {
        baseUrlTemplate: {
          type: String,
          required: true,
          description: "base url to the image file"
        },
        delimiter: {
          type: String,
          required: false,
          default: "__",
          description: "how to split the sample ID to fill in the template"
        },
        leftSwipe: {
          type: Object,
          schema: {
            label: {
              type: String,
              required: false,
              default: "Fail",
              description: "label for the left swipe button"
            },
            value: {
              type: Number,
              required: false,
              default: -1,
              description: "value stored to database"
            }
          }
        },
        rightSwipe: {
          type: Object,
          schema: {
            label: {
              type: String,
              required: false,
              default: "Pass",
              description: "label for the right swipe button"
            },
            value: {
              type: Number,
              required: false,
              default: 1,
              description: "value stored to database"
            }
          }
        },
        timing: {
          type: Object,
          schema: {
            stimulusDuration: {
              type: Number,
              required: false,
              default: null,
              description: "stimulus duration (defaults to infinite)"
            },
            timeoutValue: {
              type: Number,
              required: false,
              default: 0,
              description:
                "value stored to database when stimulus times out before user has swiped"
            },
            interStimuliDuration: {
              type: Number,
              required: false,
              default: 0,
              description:
                "time between stimuli end and next stimuli load (defaults to zero). Note: this is only as precise as the clients environment allows"
            },
            stimulusFadeIn: {
              type: Boolean,
              required: false,
              default: true,
              description:
                "sets the fade-in effect on stimulus load; set to `false` for precise timing (default: true)"
            }
          }
        }
      };
    },
    /**
     * set the swipe-left animation and vote 0
     */
    swipeLeft() {
      // set the transition style
      this.setSwipe("swipe-left");
      this.vote(this.widgetProperties.leftSwipe.value);
    },
    /**
     * set the swipe-right animation and vote 1
     */
    swipeRight() {
      // set the transition style
      this.setSwipe("swipe-right");
      this.vote(this.widgetProperties.rightSwipe.value);
    },
    /**
     * set the swipe direction based on the mouse/touch event.
     */
    onSwipe(evt) {
      if (evt.direction === 2) {
        this.swipeLeft();
      } else {
        this.swipeRight();
      }
    },
    /**
     * save the swipe direction variable.
     */
    setSwipe(sw) {
      this.swipe = sw;
    },
    /**
     * Test all the lines of this widget.
     */
    test() {
      this.getScore(1);
      this.getScore(0);
      this.getFeedback(1);
      this.getFeedback(0);
      this.getSummary(1);
      this.getSummary(0);
      this.vote(1);
      if (this.playMode === "play") {
        this.showTutorialStep(0);
        this.showTutorialStep(1);
        this.showTutorialStep(2);
      }
      this.swipeLeft();
      this.swipeRight();
      this.onSwipe({ direction: 1 });
      this.onSwipe({ direction: 2 });
      this.setSwipe("swipe-left");
      this.getPropertiesSchema();
      return 1;
    }
  }
};
</script>

<style scoped>
.imageSwipe {
  min-height: 100vh;
  height: 532px;
}
.user-card {
  max-width: 500px;
  height: fit-content;
  width: 100%;
  border: 1px solid #ccc;
  padding: 8px;
  box-shadow: 0px 2px 5px 0px #ccc;
  position: absolute;
  left: 0;
  right: 0;
  margin: auto;
  background-color: white;
}
.user-card__picture {
  width: 100%;
  display: block;
}
.user-card__picture.no-fade-in >>> .progressive-image-main {
  transition-duration: 0s;
}
.image_area {
  background: black;
  position: relative;
}
.loader {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9;
}
.user-card__name {
  margin-bottom: 0;
  margin-top: 8px;
}
.swipe-left {
  -webkit-animation: swipe-left 1s forwards;
  animation: swipe-left 1s forwards;
}
.swipe-right {
  -webkit-animation: swipe-right 1s forwards;
  animation: swipe-right 1s forwards;
}
@-webkit-keyframes swipe-left {
  to {
    -webkit-transform: rotate(-13deg) translate3d(-100%, 0, 0);
    transform: rotate(-13deg) translate3d(-100%, 0, 0);
    opacity: 0;
  }
}
@keyframes swipe-left {
  to {
    -webkit-transform: rotate(-13deg) translate3d(-100%, 0, 0);
    transform: rotate(-13deg) translate3d(-100%, 0, 0);
    opacity: 0;
  }
}
@-webkit-keyframes swipe-right {
  to {
    -webkit-transform: rotate(13deg) translate3d(100%, 0, 0);
    transform: rotate(13deg) translate3d(100%, 0, 0);
    opacity: 0;
  }
}
@keyframes swipe-right {
  to {
    -webkit-transform: rotate(13deg) translate3d(100%, 0, 0);
    transform: rotate(13deg) translate3d(100%, 0, 0);
    opacity: 0;
  }
}
/* Enter and leave animations can use different */
/* durations and timing functions.              */
/*.swipe-right-enter-active {
    transition: all .3s ease;
  }
  .swipe-right-enter-to {
    transition: all .3s ease;
  }*/
.swipe-right-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}
.swipe-right-leave-to
  /* .slide-fade-leave-active below version 2.1.8 */ {
  -webkit-transform: rotate(13deg) translate3d(100%, 0, 0);
  transform: rotate(13deg) translate3d(100%, 0, 0);
  opacity: 0;
}
/*.swipe-left-enter-active {
    transition: all .3s ease;
  }*/
.swipe-left-leave-active {
  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);
}
.swipe-left-leave-to
  /* .slide-fade-leave-active below version 2.1.8 */ {
  -webkit-transform: rotate(-13deg) translate3d(-100%, 0, 0);
  transform: rotate(-13deg) translate3d(-100%, 0, 0);
  opacity: 0;
}

.focus {
  animation: pulse 0.5s infinite alternate;
}

@keyframes pulse {
  from {
    box-shadow: 0px 0px 10px 0px #ffffff;
  }
  to {
    box-shadow: 0px 0px 20px 5px #17a2b8;
  }
}
</style>
